### IO多路复用、同步、异步、阻塞、非阻塞
1. 同步、异步是对调用来说的
2. 阻塞、非阻塞是对线程和进程来说的
3. IO多路复用主要解决`同步非阻塞`中反复轮询的问题，使用信号时间驱动进行回调通知

***

## 什么是socket？ 什么是I/O操作
``` txt
  我们都知道unix世界里，一切皆文件，而文件是是什么呢？ 文件就是一串二进制流而已，不管是socket还是FIFO、管道、终端，对我们来说一切都是文件，一切都是流。在信息交换的过程中，我们都是对这些流进行数据的收发操作，简称为I/O操作(input and output),往流中读出数据，系统调用read，写入数据，系统调用write。

  计算机里有这么多的流，我怎么知道要操作哪个流呢？对，就是文件描述符，即通常所说的fd，一个fd就是一个整数，所以，对这个整数的操作，就是对这个文件（流）的操作。我们创建一个socket,通过系统调用会返回一个文件描述符，那么剩下对socket的操作就会转化为对这个描述符的操作。
```
## 同步异步，阻塞非阻塞区别
``` txt
  同步与异步是针对应用程序与内核的交互而言的。
    同步过程中,进程触发IO操作并等待(也就是我们说的阻塞) 或者说 轮询的去查看IO操作(也就是我们说的非阻塞)是否完成.
    异步过程中,进程触发IO操作以后，程序直接返回，做自己的事情，IO交给内核来处理，完成后内核通知进程IO完成.
 
  同步和异步针对应用程序来,关注的是程序中间的协作关系;阻塞与非阻塞更关注的是单个进程的执行状态.
 
  "同步有阻塞和非阻塞之分,异步没有,它一定是非阻塞的"
  
  
  异步必定是非阻塞的,不存在异步阻塞和异步非阻塞的说法.
    真正的异步IO需要CPU的深度参与,只有用户线程在操作IO的时候,根本不去考虑IO的执行,全部都交给CPU去完成,自己只等待一个完成信号的时候，才是真正的异步IO.
    拉一个子线程去轮询、去死循环，或者使用select、poll、epool，都不是异步。
  同步都是IO阻塞、非阻塞、多路IO复用.
```
