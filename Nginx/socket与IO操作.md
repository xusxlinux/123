### IO多路复用、同步、异步、阻塞、非阻塞
1. 同步、异步是对调用来说的
2. 阻塞、非阻塞是对线程和进程来说的
3. IO多路复用主要解决`同步非阻塞`中反复轮询的问题，使用信号时间驱动进行回调通知

***

## 什么是socket？ 什么是I/O操作
``` txt
  我们都知道unix世界里，一切皆文件，而文件是是什么呢？
  文件就是一串二进制流而已，不管是socket还是FIFO、管道、终端，对我们来说一切都是文件，一切都是流。
  在信息交换的过程中，我们都是对这些流进行数据的收发操作，简称为I/O操作(input and output),往流中读出数据，系统调用read，写入数据，系统调用write。

  计算机里有这么多的流，我怎么知道要操作哪个流呢？
  就是文件描述符,即通常所说的fd,一个fd就是一个整数,所以,对这个整数的操作,就是对这个文件（流）的操作.
  我们创建一个socket,通过系统调用会返回一个文件描述符,那么剩下对socket的操作就会转化为对这个描述符的操作.
```
## 同步异步，阻塞非阻塞区别
``` txt
  同步与异步是针对应用程序与内核的交互而言的.
    同步过程中,进程触发IO操作并等待(也就是我们说的阻塞) 或者说 轮询的去查看IO操作(也就是我们说的非阻塞)是否完成.
    异步过程中,进程触发IO操作以后，程序直接返回，做自己的事情，IO交给内核来处理，完成后内核通知进程IO完成.
 
  同步和异步针对应用程序来,关注的是程序中间的协作关系;阻塞与非阻塞更关注的是单个进程的执行状态.
 
  同步有阻塞和非阻塞之分,异步没有,它一定是非阻塞的
  
  
  异步必定是非阻塞的,不存在异步阻塞和异步非阻塞的说法.
    真正的异步IO需要CPU的深度参与,只有用户线程在操作IO的时候,不考虑IO的执行,全部都交给CPU去完成,自己只等待一个完成信号的时候，才是真正的异步IO.
    拉一个子线程去轮询、去死循环，或者使用select、poll、epool，都不是异步。
    
  同步都是IO阻塞、非阻塞、多路IO复用.
  
  
  
  同步：执行一个操作之后，进程触发IO操作并等待(也就是我们说的阻塞)或者轮询的去查看IO操作(也就是我们说的非阻塞)是否完成，等待结果，然后才继续执行后续的操作。
  异步：执行一个操作后，可以去执行其他的操作，然后等待通知再回来执行刚才没执行完的操作。
  阻塞：进程给CPU传达一个任务之后，一直等待CPU处理完成，然后才执行后面的操作。
  非阻塞：进程给CPU传达任务后，继续处理后续的操作，隔断时间再来询问之前的操作是否完成。这样的过程其实也叫轮询。
```
### 阻塞
``` txt
  什么是程序的阻塞呢？
    非阻塞忙轮询：数据没来，进程就不停的去检测数据，直到数据来。(快递没来,一直打电话确认)
    阻塞：数据没来，啥都不做，直到数据来了，才进行下一步的处理。(快递没来,去干别的事情)
    
    
  阻塞,因为一个线程只能处理一个套接字的I/O事件，如果想同时处理多个，可以利用非阻塞忙轮询的方式.

    如果所有的流都没有I/O事件，只会白白浪费CPU时间片,而是引进了一个代理  select .
    它可以同时观察许多流的I/O事件，如果没有事件，代理就阻塞，线程就不会挨个挨个去轮询了.  
    但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流.
    我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作.
    所以select具有O(n)的无差别轮询复杂度,同时处理的流越多，无差别轮询时间就越长.
  
  
    epoll可以理解为event poll，不同于忙轮询和无差别轮询,epoll会把哪个流发生了怎样的I/O事件通知我们.
    所以我们说epoll实际上是事件驱动（每个事件关联上fd）,此时我们对这些流的操作都是有意义的.（复杂度降低到了O(1)）

```
### I/O多路复用
``` txt
  I/O多路复用是什么？
    有两个操作步骤：
      1. 等待数据准备好(waiting for data to be ready)对于一个套接口上的操作，这一步骤关系到数据从网络到达，并将其复制到内核的某个缓冲区.
      2. 将数据从内核缓冲区复制到进程缓冲区（copying the data from the kernel to the process）.
    
    
  阻塞I/O模型
    最广泛的模型是阻塞I/O模型,默认情况下,所有套接口都是阻塞的. 进程调用recvfrom系统调用,整个过程是阻塞的,直到数据复制到进程缓冲区时才返回（当然，系统调用被中断也会返回）

  非阻塞I/O模型
    当我们把一个套接口设置为非阻塞时,就是在告诉内核,当请求的I/O操作无法完成时,不要将进程睡眠,而是返回一个错误.
    当数据没有准备好时,内核立即返回EWOULDBLOCK错误,第四次调用系统调用时,数据已经存在,这时将数据复制到进程缓冲区中.这其中有一个操作时轮询（polling）

  I/O复用模型
    此模型用到select和poll函数,这两个函数也会使进程阻塞,select先阻塞,有活动套接字才返回.
    和阻塞I/O不同的是,这两个函数可以同时阻塞多个I/O操作,可以同时对多个读操作,多个写操作的I/O函数进行检测,直到有数据可读或可写（就是监听多个socket）.
    select被调用后,进程会被阻塞,内核监视所有select负责的socket,当有任何一个socket的数据准备好了,select就会返回套接字可读,我们就可以调用recvfrom处理数据.
    正因为阻塞I/O只能阻塞一个I/O操作,而I/O复用模型能够阻塞多个I/O操作,所以才叫做多路复用.
```
